{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///../texdown/node_modules/moo/moo.js","webpack:///../texdown/src/texdown.js","webpack:///./index.js","webpack:///./src/html.js","webpack:///./src/marker.js","webpack:///./src/sync.js","webpack:///./src/syntax.js","webpack:///./src/util.js","webpack:///./src/welcome.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;ACnEA;AACA;AACA;AAAA;AAAA;AAAA;AACA,GAAG,QAIH;AACA,CAAC;AACD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,sBAAsB;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,wBAAwB;AACxB,wBAAwB;;AAExB;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;AACL;AACA,2BAA2B;AAC3B,uBAAuB;AACvB,uBAAuB;AACvB,0BAA0B;AAC1B;;AAEA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,YAAY;AACZ;;AAEA;AACA;AACA,sBAAsB,cAAc;AACpC;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;;AAEA,iBAAiB,eAAe;AAChC;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA,iCAAiC;AACjC,sCAAsC;AACtC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,OAAO;AACP,kBAAkB;AAClB;AACA,gBAAgB;AAChB,gBAAgB;AAChB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mDAAmD;AACnD;AACA,GAAG,iBAAiB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,oCAAoC,cAAc;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,0BAA0B,YAAY;AACtC;;AAEA,CAAC;;;;;;;;;;;;;AC7cD;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iCAAiC;AACjD,cAAc;AACd,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,6BAA6B,qBAAqB;AAClD;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,aAAa;AAC5C,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnKA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA,6BAA6B,oCAAoC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;AC7BD;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA,0BAA0B,wBAAwB,EAAE;AACpD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,qCAAqC,kCAAkC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnEA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACTA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iBAAiB,EAAE;AAC3D;AACA,SAAS;AACT,MAAM;AACN;AACA;AACA;AACA;;;;;;;;;;;;;ACtCA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA,0BAA0B,wBAAwB,EAAE;AACpD;AACA,yCAAyC,qBAAqB;AAC9D;AACA;AACA,SAAS;AACT;AACA,yCAAyC,mBAAmB;AAC5D;AACA;AACA,SAAS;AACT;AACA,uCAAuC,oBAAoB;AAC3D;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,mBAAmB;AACzD;AACA;AACA,SAAS;AACT;AACA,wCAAwC,qBAAqB;AAC7D;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChDA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA,0BAA0B,WAAW;AACrC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACXA;AACA,8CAA8C,cAAc;AAC5D,4JAA4J,MAAM,yGAAyG,GAAG,EAAE,GAAG","file":"index/index.w.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./index.js\");\n","(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory) /* global define */\n  } else if (typeof module === 'object' && module.exports) {\n    module.exports = factory()\n  } else {\n    root.moo = factory()\n  }\n}(this, function() {\n  'use strict';\n\n  var hasOwnProperty = Object.prototype.hasOwnProperty\n\n  // polyfill assign(), so we support IE9+\n  var assign = typeof Object.assign === 'function' ? Object.assign :\n    // https://tc39.github.io/ecma262/#sec-object.assign\n    function(target, sources) {\n      if (target == null) {\n        throw new TypeError('Target cannot be null or undefined');\n      }\n      target = Object(target)\n\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i]\n        if (source == null) continue\n\n        for (var key in source) {\n          if (hasOwnProperty.call(source, key)) {\n            target[key] = source[key]\n          }\n        }\n      }\n      return target\n    }\n\n  var hasSticky = typeof new RegExp().sticky === 'boolean'\n\n  /***************************************************************************/\n\n  function isRegExp(o) { return o && o.constructor === RegExp }\n  function isObject(o) { return o && typeof o === 'object' && o.constructor !== RegExp && !Array.isArray(o) }\n\n  function reEscape(s) {\n    return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\n  }\n  function reGroups(s) {\n    var re = new RegExp('|' + s)\n    return re.exec('').length - 1\n  }\n  function reCapture(s) {\n    return '(' + s + ')'\n  }\n  function reUnion(regexps) {\n    var source =  regexps.map(function(s) {\n      return \"(?:\" + s + \")\"\n    }).join('|')\n    return \"(?:\" + source + \")\"\n  }\n\n  function regexpOrLiteral(obj) {\n    if (typeof obj === 'string') {\n      return '(?:' + reEscape(obj) + ')'\n\n    } else if (isRegExp(obj)) {\n      // TODO: consider /u support\n      if (obj.ignoreCase) { throw new Error('RegExp /i flag not allowed') }\n      if (obj.global) { throw new Error('RegExp /g flag is implied') }\n      if (obj.sticky) { throw new Error('RegExp /y flag is implied') }\n      if (obj.multiline) { throw new Error('RegExp /m flag is implied') }\n      return obj.source\n\n    } else {\n      throw new Error('not a pattern: ' + obj)\n    }\n  }\n\n  function objectToRules(object) {\n    var keys = Object.getOwnPropertyNames(object)\n    var result = []\n    for (var i=0; i<keys.length; i++) {\n      var key = keys[i]\n      var thing = object[key]\n      var rules = Array.isArray(thing) ? thing : [thing]\n      var match = []\n      rules.forEach(function(rule) {\n        if (isObject(rule)) {\n          if (match.length) result.push(ruleOptions(key, match))\n          result.push(ruleOptions(key, rule))\n          match = []\n        } else {\n          match.push(rule)\n        }\n      })\n      if (match.length) result.push(ruleOptions(key, match))\n    }\n    return result\n  }\n\n  function arrayToRules(array) {\n    var result = []\n    for (var i=0; i<array.length; i++) {\n      var obj = array[i]\n      if (!obj.name) {\n        throw new Error('Rule has no name: ' + JSON.stringify(obj))\n      }\n      result.push(ruleOptions(obj.name, obj))\n    }\n    return result\n  }\n\n  function ruleOptions(name, obj) {\n    if (typeof obj !== 'object' || Array.isArray(obj) || isRegExp(obj)) {\n      obj = { match: obj }\n    }\n\n    // nb. error implies lineBreaks\n    var options = assign({\n      tokenType: name,\n      lineBreaks: !!obj.error,\n      pop: false,\n      next: null,\n      push: null,\n      error: false,\n      value: null,\n      getType: null,\n    }, obj)\n\n    // convert to array\n    var match = options.match\n    options.match = Array.isArray(match) ? match : match ? [match] : []\n    options.match.sort(function(a, b) {\n      return isRegExp(a) && isRegExp(b) ? 0\n           : isRegExp(b) ? -1 : isRegExp(a) ? +1 : b.length - a.length\n    })\n    if (options.keywords) {\n      options.getType = keywordTransform(options.keywords)\n    }\n    return options\n  }\n\n  function compileRules(rules, hasStates) {\n    rules = Array.isArray(rules) ? arrayToRules(rules) : objectToRules(rules)\n\n    var errorRule = null\n    var groups = []\n    var parts = []\n    for (var i=0; i<rules.length; i++) {\n      var options = rules[i]\n\n      if (options.error) {\n        if (errorRule) {\n          throw new Error(\"Multiple error rules not allowed: (for token '\" + options.tokenType + \"')\")\n        }\n        errorRule = options\n      }\n\n      // skip rules with no match\n      if (options.match.length === 0) {\n        continue\n      }\n      groups.push(options)\n\n      // convert to RegExp\n      var pat = reUnion(options.match.map(regexpOrLiteral))\n\n      // validate\n      var regexp = new RegExp(pat)\n      if (regexp.test(\"\")) {\n        throw new Error(\"RegExp matches empty string: \" + regexp)\n      }\n      var groupCount = reGroups(pat)\n      if (groupCount > 0) {\n        throw new Error(\"RegExp has capture groups: \" + regexp + \"\\nUse (?: â€¦ ) instead\")\n      }\n      if (!hasStates && (options.pop || options.push || options.next)) {\n        throw new Error(\"State-switching options are not allowed in stateless lexers (for token '\" + options.tokenType + \"')\")\n      }\n\n      // try and detect rules matching newlines\n      if (!options.lineBreaks && regexp.test('\\n')) {\n        throw new Error('Rule should declare lineBreaks: ' + regexp)\n      }\n\n      // store regex\n      parts.push(reCapture(pat))\n    }\n\n    var suffix = hasSticky ? '' : '|(?:)'\n    var flags = hasSticky ? 'ym' : 'gm'\n    var combined = new RegExp(reUnion(parts) + suffix, flags)\n\n    return {regexp: combined, groups: groups, error: errorRule}\n  }\n\n  function compile(rules) {\n    var result = compileRules(rules)\n    return new Lexer({start: result}, 'start')\n  }\n\n  function compileStates(states, start) {\n    var keys = Object.getOwnPropertyNames(states)\n    if (!start) start = keys[0]\n\n    var map = Object.create(null)\n    for (var i=0; i<keys.length; i++) {\n      var key = keys[i]\n      map[key] = compileRules(states[key], true)\n    }\n\n    for (var i=0; i<keys.length; i++) {\n      var groups = map[keys[i]].groups\n      for (var j=0; j<groups.length; j++) {\n        var g = groups[j]\n        var state = g && (g.push || g.next)\n        if (state && !map[state]) {\n          throw new Error(\"Missing state '\" + state + \"' (in token '\" + g.tokenType + \"' of state '\" + keys[i] + \"')\")\n        }\n        if (g && g.pop && +g.pop !== 1) {\n          throw new Error(\"pop must be 1 (in token '\" + g.tokenType + \"' of state '\" + keys[i] + \"')\")\n        }\n      }\n    }\n\n    return new Lexer(map, start)\n  }\n\n  function keywordTransform(map) {\n    var reverseMap = Object.create(null)\n    var byLength = Object.create(null)\n    var types = Object.getOwnPropertyNames(map)\n    for (var i=0; i<types.length; i++) {\n      var tokenType = types[i]\n      var item = map[tokenType]\n      var keywordList = Array.isArray(item) ? item : [item]\n      keywordList.forEach(function(keyword) {\n        (byLength[keyword.length] = byLength[keyword.length] || []).push(keyword)\n        if (typeof keyword !== 'string') {\n          throw new Error(\"keyword must be string (in keyword '\" + tokenType + \"')\")\n        }\n        reverseMap[keyword] = tokenType\n      })\n    }\n\n    // fast string lookup\n    // https://jsperf.com/string-lookups\n    function str(x) { return JSON.stringify(x) }\n    var source = ''\n    source += '(function(value) {\\n'\n    source += 'switch (value.length) {\\n'\n    for (var length in byLength) {\n      var keywords = byLength[length]\n      source += 'case ' + length + ':\\n'\n      source += 'switch (value) {\\n'\n      keywords.forEach(function(keyword) {\n        var tokenType = reverseMap[keyword]\n        source += 'case ' + str(keyword) + ': return ' + str(tokenType) + '\\n'\n      })\n      source += '}\\n'\n    }\n    source += '}\\n'\n    source += '})'\n    return eval(source) // getType\n  }\n\n  /***************************************************************************/\n\n  var Lexer = function(states, state) {\n    this.startState = state\n    this.states = states\n    this.buffer = ''\n    this.stack = []\n    this.reset()\n  }\n\n  Lexer.prototype.reset = function(data, info) {\n    this.buffer = data || ''\n    this.index = 0\n    this.line = info ? info.line : 1\n    this.col = info ? info.col : 1\n    this.setState(info ? info.state : this.startState)\n    return this\n  }\n\n  Lexer.prototype.save = function() {\n    return {\n      line: this.line,\n      col: this.col,\n      state: this.state,\n    }\n  }\n\n  Lexer.prototype.setState = function(state) {\n    if (!state || this.state === state) return\n    this.state = state\n    var info = this.states[state]\n    this.groups = info.groups\n    this.error = info.error || {lineBreaks: true, shouldThrow: true}\n    this.re = info.regexp\n  }\n\n  Lexer.prototype.popState = function() {\n    this.setState(this.stack.pop())\n  }\n\n  Lexer.prototype.pushState = function(state) {\n    this.stack.push(this.state)\n    this.setState(state)\n  }\n\n  Lexer.prototype._eat = hasSticky ? function(re) { // assume re is /y\n    return re.exec(this.buffer)\n  } : function(re) { // assume re is /g\n    var match = re.exec(this.buffer)\n    // will always match, since we used the |(?:) trick\n    if (match[0].length === 0) {\n      return null\n    }\n    return match\n  }\n\n  Lexer.prototype._getGroup = function(match) {\n    if (match === null) {\n      return -1\n    }\n\n    var groupCount = this.groups.length\n    for (var i = 0; i < groupCount; i++) {\n      if (match[i + 1] !== undefined) {\n        return i\n      }\n    }\n    throw new Error('oops')\n  }\n\n  function tokenToString() {\n    return this.value\n  }\n\n  Lexer.prototype.next = function() {\n    var re = this.re\n    var buffer = this.buffer\n\n    var index = re.lastIndex = this.index\n    if (index === buffer.length) {\n      return // EOF\n    }\n\n    var match = this._eat(re)\n    var i = this._getGroup(match)\n\n    var group, text\n    if (i === -1) {\n      group = this.error\n\n      // consume rest of buffer\n      text = buffer.slice(index)\n\n    } else {\n      text = match[0]\n      group = this.groups[i]\n    }\n\n    // count line breaks\n    var lineBreaks = 0\n    if (group.lineBreaks) {\n      var matchNL = /\\n/g\n      var nl = 1\n      if (text === '\\n') {\n        lineBreaks = 1\n      } else {\n        while (matchNL.exec(text)) { lineBreaks++; nl = matchNL.lastIndex }\n      }\n    }\n\n    var token = {\n      type: (group.getType && group.getType(text)) || group.tokenType,\n      value: group.value ? group.value(text) : text,\n      text: text,\n      toString: tokenToString,\n      offset: index,\n      lineBreaks: lineBreaks,\n      line: this.line,\n      col: this.col,\n    }\n    // nb. adding more props to token object will make V8 sad!\n\n    var size = text.length\n    this.index += size\n    this.line += lineBreaks\n    if (lineBreaks !== 0) {\n      this.col = size - nl + 1\n    } else {\n      this.col += size\n    }\n    // throw, if no rule with {error: true}\n    if (group.shouldThrow) {\n      throw new Error(this.formatError(token, \"invalid syntax\"))\n    }\n\n    if (group.pop) this.popState()\n    else if (group.push) this.pushState(group.push)\n    else if (group.next) this.setState(group.next)\n    return token\n  }\n\n  if (typeof Symbol !== 'undefined' && Symbol.iterator) {\n    var LexerIterator = function(lexer) {\n      this.lexer = lexer\n    }\n\n    LexerIterator.prototype.next = function() {\n      var token = this.lexer.next()\n      return {value: token, done: !token}\n    }\n\n    LexerIterator.prototype[Symbol.iterator] = function() {\n      return this\n    }\n\n    Lexer.prototype[Symbol.iterator] = function() {\n      return new LexerIterator(this)\n    }\n  }\n\n  Lexer.prototype.formatError = function(token, message) {\n    var value = token.value\n    var index = token.offset\n    var eol = token.lineBreaks ? value.indexOf('\\n') : value.length\n    var start = Math.max(0, index - token.col + 1)\n    var firstLine = this.buffer.substring(start, index + eol)\n    message += \" at line \" + token.line + \" col \" + token.col + \":\\n\\n\"\n    message += \"  \" + firstLine + \"\\n\"\n    message += \"  \" + Array(token.col).join(\" \") + \"^\"\n    return message\n  }\n\n  Lexer.prototype.clone = function() {\n    return new Lexer(this.states, this.state)\n  }\n\n  Lexer.prototype.has = function(tokenType) {\n    for (var s in this.states) {\n      var groups = this.states[s].groups\n      for (var i=0; i<groups.length; i++) {\n        var group = groups[i]\n        if (group.tokenType === tokenType) return true\n        if (group.keywords && hasOwnProperty.call(group.keywords, tokenType)) {\n          return true\n        }\n      }\n    }\n    return false\n  }\n\n\n  return {\n    compile: compile,\n    states: compileStates,\n    error: Object.freeze({error: true}),\n  }\n\n}))\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst moo = require(\"moo\");\nfunction isVal(node) {\n    return node.type === ''\n        || node.type === '$$'\n        || node.type === '$';\n}\nfunction isLink(node) {\n    return node.type === 'a' || node.type === 'img';\n}\nfunction visit(ast, visitor) {\n    const d = visitor.doc();\n    ast.kids.forEach(k => {\n        visitNode(k, visitor, d);\n    });\n    return d;\n}\nexports.visit = visit;\nfunction visitNode(node, visitor, parent) {\n    if (node.type === 'br')\n        visitor.br(parent);\n    else if (isVal(node))\n        visitor[node.type](node.val, parent);\n    else if (isLink(node))\n        visitor[node.type](node.title, node.href, parent);\n    else {\n        const p = visitor.element(node.type, parent);\n        node.kids.forEach(k => visitNode(k, visitor, p));\n    }\n}\nexports.visitNode = visitNode;\nfunction texdown(markDown) {\n    const doc = { type: 'div', kids: [] };\n    const ps = [doc];\n    const top = () => ps[ps.length - 1] || doc;\n    const lexer = moo.compile({\n        h6: /^###### /,\n        h5: /^##### /,\n        h4: /^#### /,\n        h3: /^### /,\n        h2: /^## /,\n        h1: /^# /,\n        uli: /^\\- /,\n        oli: /^\\d+\\. /,\n        b: '*',\n        i: '/',\n        u: '_',\n        a: /\\[[^\\]\\n]*\\]\\([^)\\n]*\\)/,\n        img: /!\\[[^\\]\\n]*\\]\\([^)\\n]*\\)/,\n        $$: /^\\$\\$$(?:\\\\\\$|[^$])+^\\$\\$\\n/,\n        $: /\\$(?:\\\\\\$|[^\\n$])+\\$/,\n        esc: /\\\\\\*|\\\\_|\\\\\\$|\\\\\\\\|^\\\\#/,\n        txt: /[^/!\\n*_$\\\\]+|[!*_$\\\\/]/,\n        blank: { match: /^\\n/, lineBreaks: true },\n        eol: { match: /\\n/, lineBreaks: true }\n    });\n    lexer.reset(markDown);\n    while (true) {\n        const token = lexer.next();\n        if (!token)\n            break;\n        const startParagraphOrLineIfNeeded = () => {\n            if (ps.length === 1) {\n                const p = { type: 'p', kids: [] };\n                doc.kids.push(p);\n                ps.push(p);\n            }\n            if (top().type === 'p') {\n                const line = { type: 'div', kids: [] };\n                top().kids.push(line);\n                ps.push(line);\n            }\n        };\n        const delimiter = () => {\n            const type = token.type;\n            if (top().type === type) {\n                ps.pop();\n                return;\n            }\n            startParagraphOrLineIfNeeded();\n            const c = { type: type, kids: [] };\n            top().kids.push(c);\n            ps.push(c);\n        };\n        const text = (str) => {\n            startParagraphOrLineIfNeeded();\n            top().kids.push({ type: '', val: str });\n        };\n        const list = (type) => {\n            if (top().type !== type) {\n                resetNodes();\n                const l = { type: type, kids: [] };\n                doc.kids.push(l);\n                ps.push(l);\n            }\n            const li = { type: 'li', kids: [] };\n            top().kids.push(li);\n            ps.push(li);\n        };\n        const resetNodes = () => ps.splice(1, ps.length - 1);\n        const node = () => {\n            const c = { type: token.type, kids: [] };\n            doc.kids.push(c);\n            resetNodes();\n            ps.push(c);\n        };\n        const extractLink = /.?\\[([^\\]]*)\\]\\(([^)]*)\\)/;\n        const link = (type) => {\n            startParagraphOrLineIfNeeded();\n            const res = extractLink.exec(token.text);\n            if (res === null)\n                throw 'expecting link';\n            top().kids.push({\n                type: type,\n                title: res[1],\n                href: res[2]\n            });\n        };\n        const actions = {\n            h1: node,\n            h2: node,\n            h3: node,\n            h4: node,\n            h5: node,\n            h6: node,\n            uli: () => list('ul'),\n            oli: () => list('ol'),\n            b: delimiter,\n            i: delimiter,\n            u: delimiter,\n            $$: () => {\n                const tex = token.text.substring(2, token.text.length - 3);\n                top().kids.push({\n                    type: '$$',\n                    val: tex\n                });\n            },\n            $: () => {\n                startParagraphOrLineIfNeeded();\n                const tex = token.text.substring(1, token.text.length - 1);\n                top().kids.push({\n                    type: '$',\n                    val: tex\n                });\n            },\n            a: () => link('a'),\n            img: () => link('img'),\n            txt: () => text(token.text),\n            esc: () => text(token.text.substr(1)),\n            blank: () => {\n                resetNodes();\n                doc.kids.push({ type: 'br' });\n            },\n            eol: () => {\n                ps.pop();\n            }\n        };\n        if (token.type)\n            actions[token.type]();\n    }\n    return doc;\n}\nexports.texdown = texdown;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar marker_1 = require(\"./src/marker\");\nvar welcome_1 = require(\"./src/welcome\");\nvar sync_1 = require(\"./src/sync\");\nvar util_1 = require(\"./src/util\");\ndocument.addEventListener('DOMContentLoaded', function () {\n    var get = function (id) { return document.getElementById(id); };\n    var input = get('input');\n    var editor = get('editor');\n    var output = get('output');\n    var update = function () {\n        var _a = marker_1.parse(util_1.readHash()), syntax = _a[0], html = _a[1];\n        editor.innerHTML = output.innerHTML = '';\n        editor.appendChild(syntax);\n        output.appendChild(html);\n        input.style.height = (editor.scrollHeight + 40) + 'px';\n    };\n    input.addEventListener('input', function () {\n        window.location.hash = encodeURIComponent(input.value);\n    });\n    window.onhashchange = function () {\n        requestAnimationFrame(update);\n    };\n    if (window.location.hash.length <= 1)\n        window.location.hash = welcome_1.welcome;\n    input.value = util_1.readHash();\n    update();\n    sync_1.sync(get('lcol'), get('rcol'));\n});\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar texdown_1 = require(\"texdown\");\nvar util_1 = require(\"./util\");\nexports.html = function (node) {\n    var dataSync = 0;\n    var vHtml = {\n        doc: function () { return util_1.e('div'); },\n        '': function (val, parent) {\n            var span = util_1.e('span');\n            span.innerText = val;\n            parent.appendChild(span);\n        },\n        $: function (val, parent) {\n            var span = util_1.e('span');\n            try {\n                katex.render(val, span, {\n                    throwOnError: false\n                });\n            }\n            catch (e) {\n                console.log(e);\n            }\n            span.dir = 'ltr';\n            parent.appendChild(span);\n        },\n        $$: function (val, parent) {\n            var div = util_1.e('div');\n            try {\n                katex.render(val, div, {\n                    displayMode: true,\n                    throwOnError: false\n                });\n            }\n            catch (e) {\n                console.log(e);\n            }\n            parent.appendChild(div);\n        },\n        br: function (parent) {\n            var span = util_1.e('span');\n            span.innerText = ' ';\n            parent.appendChild(span);\n        },\n        a: function (title, href, parent) {\n            var a = util_1.e('a');\n            a.title = title;\n            a.href = href;\n            a.innerText = title || href;\n            parent.appendChild(a);\n        },\n        img: function (title, src, parent) {\n            var img = util_1.e('img');\n            img.title = title;\n            img.src = src;\n            parent.appendChild(img);\n        },\n        element: function (type, parent) {\n            var el = util_1.e(type, { 'data-sync': String(dataSync++) });\n            parent.appendChild(el);\n            if (type === 'div')\n                el.className = 'line';\n            // else if (type === 'p') el.dir = 'auto'\n            return el;\n        }\n    };\n    return texdown_1.visit(node, vHtml);\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar texdown_1 = require(\"texdown\");\nvar html_1 = require(\"./html\");\nvar syntax_1 = require(\"./syntax\");\nexports.parse = function (str) {\n    var ast = texdown_1.texdown(str);\n    // console.log(JSON.stringify(ast, null, 2))\n    return [syntax_1.syntax(ast), html_1.html(ast)];\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction sync(e1, e2) {\n    var firstVisible = function (scrollTop, es) {\n        for (var i = 0; i < es.length; i++) {\n            var e = es.item(i);\n            if (e.offsetTop > scrollTop)\n                return e;\n        }\n        throw 'something wrong';\n    };\n    var syncing = false;\n    var sync = function (e1, e2) {\n        var s1 = firstVisible(e1.scrollTop, e1.querySelectorAll('[data-sync]'));\n        var s2 = e2.querySelectorAll(\"[data-sync=\\\"\" + s1.getAttribute('data-sync') + \"\\\"]\").item(0);\n        s2.scrollIntoView({\n            behavior: 'smooth'\n        });\n    };\n    var handler = function (e1, e2) { return function () {\n        if (syncing)\n            return;\n        syncing = true;\n        setTimeout(function () {\n            try {\n                sync(e1, e2);\n            }\n            catch (e) {\n                console.error(e);\n            }\n            finally {\n                setTimeout(function () { syncing = false; }, 1000);\n            }\n        }, 300);\n    }; };\n    e1.addEventListener('scroll', handler(e1, e2));\n    e2.addEventListener('scroll', handler(e2, e1));\n}\nexports.sync = sync;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar texdown_1 = require(\"texdown\");\nvar util_1 = require(\"./util\");\nexports.syntax = function (node) {\n    var dataSync = 0;\n    var vSyntax = {\n        doc: function () { return util_1.e('div'); },\n        '': function (val, parent) {\n            var span = util_1.e('span', { 'data-type': 'txt' });\n            span.innerText = val;\n            parent.appendChild(span);\n        },\n        $: function (val, parent) {\n            var span = util_1.e('span', { 'data-type': '$' });\n            span.innerText = val;\n            parent.appendChild(span);\n        },\n        $$: function (val, parent) {\n            var div = util_1.e('div', { 'data-type': '$$' });\n            div.innerText = val;\n            parent.appendChild(div);\n        },\n        br: function (parent) {\n            var br = util_1.e('br');\n            parent.appendChild(br);\n        },\n        a: function (title, href, parent) {\n            var a = util_1.e('span', { 'data-type': 'a' });\n            a.innerText = \"[\" + title + \"](\" + href + \")\";\n            parent.appendChild(a);\n        },\n        img: function (title, src, parent) {\n            var img = util_1.e('span', { 'data-type': 'img' });\n            img.innerText = \"![\" + title + \"](\" + src + \")\";\n            parent.appendChild(img);\n        },\n        element: function (type, parent) {\n            var s = util_1.e('span', {\n                'data-type': type,\n                'data-sync': String(dataSync++)\n            });\n            parent.appendChild(s);\n            s.dir = 'auto';\n            return s;\n        }\n    };\n    return texdown_1.visit(node, vSyntax);\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.readHash = function () {\n    return decodeURIComponent(window.location.hash.substr(1));\n};\nexports.e = function (name, atts) {\n    if (atts === void 0) { atts = {}; }\n    var e = document.createElement(name);\n    for (var k in atts)\n        e.setAttribute(k, atts[k]);\n    return e;\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.welcome = encodeURIComponent(\"\\n# $\\\\TeX$.ninja\\n\\n## Text\\n\\n- plain\\n- *bold*\\n- /italic/\\n- _underline_\\n\\n## math\\n\\n1. $a \\\\leq b$\\n2. $\\\\sum_{i = 1}^3 = 6$\\n\\n[TeX.ninja](http://tex.ninja) - write $\\\\LaTeX$ like a:\\n\\n![](ninja.png)\\n\\n$$\\n\\\\int \\\\frac{1}{x}\\\\;dx = \\\\ln|x| + C\\n$$\\n\");\n"],"sourceRoot":""}